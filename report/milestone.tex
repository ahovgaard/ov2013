\documentclass[12pt,a4paper]{article}

% use utf8 encoding
\usepackage[utf8]{inputenc}

% math environments (eg. align) and symbols
\usepackage{amsmath, amssymb}

% import graphicx for managing pictures
\usepackage{graphicx}

% import float for positioning using [H] in figures
\usepackage{float}

% import colortbl for coloring tabular cells
\usepackage{colortbl}

% tikz for drawing diagrams
\usepackage{tikz}
\usetikzlibrary{automata,positioning,arrows}

% lstlisting environment for source code
\usepackage{listings}

% listings config for writing context-free grammars
\lstset{
  basicstyle=\ttfamily,
  columns = fixed,
  mathescape,
  xleftmargin=5em,
  literate={->}{$\rightarrow$}{2}
           {alpha}{$\alpha$}{1}
           {delta}{$\delta$}{1}
           {epsilon}{$\varepsilon$}{1}
}

\begin{document}
\title{Introduction to Compilers (OV)\\
       Milestone status report}
\author{Anders Kiel Hovgaard\\
        Daniel Gavin\\
        Rúni Klein Hansen}
\date{December 6, 2013}
\maketitle

\section{Introduction}
The task at hand is to construct a working parser for the language Paladim,
created for the ``Oversætter''-course 2013. The tool used is a parser generator
named mosmlyac.\\
In this milestone report we will focus on getting the parser up and running
while f.ex. evaluation of boolean expressions will be saved for later.


\section{Parser implementation in mosmlyac}
Our main goal was to create the same language as the LL(1) parser. We started with the grammar, which was given with the 
assignment. We then modified the grammar to conform with mosmlyacc, and also modified certain areas of the grammar that was
giving conflicts(You can see the conflicts we had in the resolving parse conflicts section.). 
\\
\\
We also changed some of the given grammar that we thought could be better expressed with some new grammar, but still did that same thing as the given grammar(See the Changes to the paladim grammar section for that.).
\\
\\
When we were done with the grammar we also had to make sure we used the correct return types, we used the AbSyn.sml file to check for the
the datatype types to use, and we also looked in the LL(1) parser to see what types that parser used for better understanding of the 
types.


\section{Resolving parse conflicts}
We fixed the dangling-else ambiguity by making the \texttt{then} and
\texttt{else} symbols right-associative and giving them the same precedence,
i.e. by using the following mosmlyac declaration:

\begin{verbatim}
  %right TThen TElse 
\end{verbatim}
\
We had a shift/reduce conflict with the modified Decs grammar(which you can see in the changes to the paladin grammar section). The
way we solved the problem was to force a reduce over a shift by making Tid and TSemi non associative, which fixed the conflict problem.
\\
\\
We also received countless reduce conflicts from the rewritten operation expressions(See changes to paladim grammar section).
This was because the parser did not know which reduction it should choose, e.g. 2+3*3, Plus(2, Times(3,3)) or Times(Plus(2, 3), 3). To fix
this we introduced precedence and associativity for each operation and that fixed the problem. Please see the appendix for the precedence
and associativity assignments for each operation in the parser.grm code.
\section{Changes to the Paladim grammar}
We removed the OP non terminal and instead created all the scenarios for the operations instead.
\begin{lstlisting}
	$Exp$  ->   $Exp$ $OP$ $Exp$ 
	$Op$   ->  TPlus | TMinus | TTimes | TSlash 
	$Op$   ->  TEq | TLess | TAnd | TOr
\end{lstlisting}
to
\begin{lstlisting}
  $Exp$  ->   $Exp$ TPlus  $Exp$
	$Exp$  ->   $Exp$ TMinus $Exp$
	$Exp$  ->   $Exp$ TTimes $Exp$
	$Exp$  ->   $Exp$ TSlash $Exp$
	$Exp$  ->   $Exp$ TEq    $Exp$
	$Exp$  ->   $Exp$ TLess  $Exp$
	$Exp$  ->   $Exp$ TAnd   $Exp$
	$Exp$  ->   $Exp$ TOr    $Exp$ 
\end{lstlisting}
We decided to remove the left recursion because of a reduce/shift conflict.
\begin{lstlisting}
  $Decs$  ->    $Decs$ $Dec$ ; 
  $Decs$  ->    $Dec$ ;
\end{lstlisting}
to
\begin{lstlisting}
  $Decs$    ->   $Dec$ ; $Decs$
  $Decs$   ->    $Dec$ ;
\end{lstlisting}
\section{Testing methodology}
At the current time in the spacetime-continuum we are only able to compile a subset
of the programs included in the \textbf{DATA}-folder. Those programs are:\\
\begin{enumerate}
  \item fibRex.pal
  \item fibWhile.pal
  \item proctest.pal
  \item readtest.pal
  \item shortest.pal
\end{enumerate}

Also whenever we changed something new in the grammar, e.g. modified some precedence for the Expression, we would use our grammar
script which allows us to create the AbSyn syntax tree without it being further processed. This was quite handy since we can actually
test things that aren't implemented yet for the compiler, typecheck, etc. A good example of the usage of the grammar script was
when we had to test the 'or' and 'not' operators. Since the compiler still does not support these operations, we had to use this script
to see if our precedence was correct - which it is.
\\
\\
Whenever we had made some major changes to the parser, we would run all the aforementioned pal files
in interpreter and compile mode to see if everything still works. Before we even started coding the grammar for the parser, we 
saw how the LL(1) parser handled the aforementioned pal files, and since we are building a replacement for the LL(1) parser, our new
parser should at least handle the same files and give the same output as the LL parser. It was therefore fairly easy to see if the parser
tests were correct, regarding the pal files. Pal files like the fibWhile and fibRec were also quite easy to test, since they took some
input and gave some output, which made it alot more easy to make test cases.


\section{Conclusion}
Using the knowledge of the LL(1) parser(given from the assignment) and that of yacc, we rewrote the grammar from the given grammar. Using our knowledge of LR parsers to handle shift/reduce conflicts, we used associativity to handle reduce/shift conflicts. By testing all 
of our changes to the parser, we can be quite certain that it actually works as intended, and even though we didn't do really structured
test cases, we did test quite a lot. I think in the later parts of the project a more structured testing approach would be better, but
we felt that the tests were quite simple for the parser, and therefore testing of the already given pal files and our grammaTester script were enough.

\begin{thebibliography}{9}
  \bibitem[ICD]{icd}
    Torben Ægidius Mogensen,
    \emph{Introduction to Compiler Design},
    Springer London, first edition, 2011.
\end{thebibliography}

\end{document}
