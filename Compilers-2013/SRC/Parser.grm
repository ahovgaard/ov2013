%{
  (* See the Moscow ML manual for the syntax and structure. Roughly:
   *
   * `%``{`
   *     header (* with ML-like comments *)
   *     Any SML code is copied to the beginning of Parser.sml, after the token
   *     datatype declaration.
   * `%``}`
   *     declarations  /* with c-like comments */
   * `%``%`
   *     rules         /* with c-like comments */
   * `%``%`
   *     trailer (* with ML-like comments *)
   *     Any SML code is copied to the end of Parser.sml.
   * EOF
   *
   * The (optional) header and trailer contain ML code to include in the
   * generated file (after the data declaration and at the end).
   *)

  type Pos   = int * int  (* position: (line, column) *)
  type Ident = string     (* identifier *)
  (* Unfortunately, we cannot use these types in the declarations -
   * the code ends up _after_ the data declaration. *)

  (* parse exception *)
  exception SyntaxError of string * Pos


  (* Get position tuple from Location structure, for error reporting *)
  fun getPos () =
    case Location.getCurrentLocation () of
         Location.Loc (l, r) => (l, r)
       | _ => raise Fail "could not get location" (* shouldn't happen *)
%}

/* Token type definitions (will often be used in the Lexer) */

/* Tokens use position attribute for demonstration (see below for Lexer)
 * As mentioned, the SML code above ends up _after_ this data declaration,
 * so we cannot use any types defined _above_ at this point of the file.
 */

/* Keywords */
%token <int * int> TProgram   TFunction   TProcedure
%token <int * int> TVar       TBegin      TEnd
%token <int * int> TIf        TThen       TElse
%token <int * int> TWhile     TDo         TReturn

/* Type keywords */
%token <int * int> TArray     TOf
%token <int * int> TInt       TChar       TBool

/* Symbols */
%token <int * int> TSemi      TColon      TComma      TAssign

/* Operations */
%token <int * int> TPlus      TMinus      TTimes      TSlash /* arithmetic */
%token <int * int> TEq        TLess       TAnd               /* comparison and bool */

/* Parentheses of different kind */
%token <int * int> TLParen    TRParen
%token <int * int> TLCurly    TRCurly
%token <int * int> TLBracket  TRBracket

/* Identifiers */
%token <string * (int * int)> TId 

/* Literals */
%token <int * (int * int)>    TNLit
%token <bool * (int * int)>   TBLit
%token <char * (int * int)>   TCLit
%token <string * (int * int)> TSLit

/* EOF special token */
%token <int * int>            TEOF

/* Start symbol */
%start Prog

/******************************************************************************
 * Types returned by rules below 
 *****************************************************************************/

/* Program structure */
%type <AbSyn.Prog> Prog
%type <AbSyn.FunDec list> FunDecs
%type <AbSyn.FunDec> FunDec
%type <AbSyn.StmtBlock> Block

/* Variables and parameter declarations, types */
%type <AbSyn.Dec list> PDecl
%type <AbSyn.Dec list> Params
%type <AbSyn.Dec> Dec
%type <AbSyn.Dec list> Decs
%type <AbSyn.Type> Type


%%

/******************************************************************************
 * Rules - a separate start rule is added automatically
 *****************************************************************************/

/* Program structure */
Prog    : TProgram TId TSemi FunDecs { $4 }   /* $4 : AbSyn.FunDec list */

FunDecs : FunDecs FunDec { $1 @ [$2] }
        | FunDec { [$1] }

FunDec  : TFunction TId TLParen PDecl TRParen TColon Type Block TSemi
            { AbSyn.Func ($7, #1 $2, $4, $8, getPos ()) }
            /* Func of Type * Ident * Dec list * StmtBlock * Pos */
        | TProcedure TId TLParen PDecl TRParen Block TSemi
            { AbSyn.Proc (#1 $2, $4, $6, getPos ()) }
            /* Proc of Ident * Dec list * StmtBlock * Pos */

Block   : { AbSyn.Block ([], []) }


/* Variables and parameter declarations, types */
PDecl  : Params             { $1 }
       |                    { [] }

Params : Params TSemi Dec   { $1 @ [$3] }
       | Dec                { [$1] }

Dec    : TId TColon Type    { AbSyn.Dec (#1 $1, $3, getPos ()) }
                            /* Dec of Ident * Type * Pos */

Decs   : Decs Dec TSemi     { $1 @ [$2] }
       | Dec TSemi          { [$1] }

Type   : TInt               { AbSyn.Int (getPos ()) }
       | TChar              { AbSyn.Char (getPos ()) }
       | TBool              { AbSyn.Bool (getPos ()) }
       | TArray TOf Type    { AbSyn.Array ($3, getPos ()) }

%%

(* SML trailer
 *
 * At this point we can use the parse function (%start above), whose type is
 *   Start : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Exp;
 *
 * (Lexing.lexbuf -> token) is usually mosmllex-generated.
 *
 *)
